'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runIntegrationTests = runIntegrationTests;

var _child_process = require('child_process');

var _tape = require('tape');

var _tape2 = _interopRequireDefault(_tape);

var _lib = require('../../../lib');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function pExec(cmd) {
  return new Promise(function (resolve, reject) {
    (0, _child_process.exec)(cmd, function (err, stdout, stderr) {
      if (err) {
        reject(err);
      } else {
        resolve(stdout, stderr);
      }
    });
  });
}

function initializeBlockstackCore() {
  return pExec('docker pull quay.io/blockstack/integrationtests:develop').then(function () {
    console.log('Pulled latest docker image');
    return pExec('docker stop test-bsk-core ;\n        docker rm test-bsk-core ;\n        rm -rf /tmp/.blockstack_int_test').catch(function () {
      return true;
    });
  }).then(function () {
    return pExec('docker run --name test-bsk-core -dt -p 16268:16268 -p 18332:18332 ' + '-e BLOCKSTACK_TEST_CLIENT_RPC_PORT=16268 ' + '-e BLOCKSTACK_TEST_CLIENT_BIND=0.0.0.0 ' + '-e BLOCKSTACK_TEST_BITCOIND_ALLOWIP=172.17.0.0/16 ' + 'quay.io/blockstack/integrationtests:develop ' + 'blockstack-test-scenario --interactive 2 ' + 'blockstack_integration_tests.scenarios.portal_test_env');
  }).then(function () {
    console.log('Started regtest container, waiting until initialized');
    return pExec('docker logs -f test-bsk-core | grep -q \'Test finished\'');
  });
}

function shutdownBlockstackCore() {
  return pExec('docker stop test-bsk-core');
}

function runIntegrationTests() {
  (0, _tape2.default)('registerName', function (t) {
    t.plan(7);

    _lib.config.network = _lib.network.defaults.LOCAL_REGTEST;
    var myNet = _lib.config.network;

    var dest = '19238846ac60fa62f8f8bb8898b03df79bc6112600181f36061835ad8934086001';
    var destAddress = (0, _lib.hexStringToECPair)(dest).getAddress();

    var btcDest = '897f1b92041b798580f96b8be379053f6276f04eb7590a9042a62059d46d6fc301';
    var btcDestAddress = (0, _lib.hexStringToECPair)(btcDest).getAddress();

    var payer = 'bb68eda988e768132bc6c7ca73a87fb9b0918e9a38d3618b74099be25f7cab7d01';

    var secondOwner = '54164693e3803223f7fa9a004997bfbf1475f5c44f65593fa45c6783086dafec01';
    var transferDestination = (0, _lib.hexStringToECPair)(secondOwner).getAddress();

    var renewalDestination = 'myPgwEX2ddQxPPqWBRkXNqL3TwuWbY29DJ';

    var zfTest = '$ORIGIN aaron.id\n$TTL 3600\n_http._tcp URI 10 1 ' + ('"https://gaia.blockstacktest.org/hub/' + destAddress + '/0/profile.json"');
    var zfTest2 = '$ORIGIN aaron.id\n$TTL 3600\n_http._tcp URI 10 1 ' + ('"https://gaia.blockstacktest.org/hub/' + destAddress + '/3/profile.json"');
    var renewalZF = '$ORIGIN aaron.id\n$TTL 3600\n_http._tcp URI 10 1 ' + ('"https://gaia.blockstacktest.org/hub/' + destAddress + '/4/profile.json"');

    initializeBlockstackCore().then(function () {
      console.log('Blockstack Core initialized.');
      return _lib.transactions.makePreorder('aaron.id', destAddress, payer);
    }).then(function (rawtx) {
      return myNet.broadcastTransaction(rawtx);
    }).then(function () {
      console.log('PREORDER broadcasted, waiting 30 seconds.');
      return new Promise(function (resolve) {
        return setTimeout(resolve, 30000);
      });
    }).then(function () {
      return _lib.transactions.makeRegister('aaron.id', destAddress, payer, zfTest);
    }).then(function (rawtx) {
      return myNet.broadcastTransaction(rawtx);
    }).then(function () {
      console.log('REGISTER broadcasted, waiting 30 seconds.');
      return new Promise(function (resolve) {
        return setTimeout(resolve, 30000);
      });
    }).then(function () {
      return myNet.broadcastZoneFile(zfTest);
    }).then(function () {
      return fetch(myNet.blockstackAPIUrl + '/v1/names/aaron.id');
    }).then(function (resp) {
      return resp.json();
    }).then(function (nameInfo) {
      t.equal(myNet.coerceAddress(nameInfo.address), destAddress, 'aaron.id should be owned by ' + destAddress);
      t.equal(nameInfo.zonefile, zfTest, 'zonefile should be properly set');
    }).then(function () {
      return _lib.transactions.makeUpdate('aaron.id', dest, payer, zfTest2);
    }).then(function (rawtx) {
      return myNet.broadcastTransaction(rawtx);
    }).then(function () {
      console.log('UPDATE broadcasted, waiting 30 seconds.');
      return new Promise(function (resolve) {
        return setTimeout(resolve, 30000);
      });
    }).then(function () {
      return myNet.broadcastZoneFile(zfTest2);
    }).then(function () {
      return fetch(myNet.blockstackAPIUrl + '/v1/names/aaron.id');
    }).then(function (resp) {
      return resp.json();
    }).then(function (nameInfo) {
      t.equal(nameInfo.zonefile, zfTest2, 'zonefile should be updated');
    }).then(function () {
      return _lib.transactions.makeTransfer('aaron.id', transferDestination, dest, payer);
    }).then(function (rawtx) {
      return myNet.broadcastTransaction(rawtx);
    }).then(function () {
      console.log('TRANSFER broadcasted, waiting 30 seconds.');
      return new Promise(function (resolve) {
        return setTimeout(resolve, 30000);
      });
    }).then(function () {
      return fetch(myNet.blockstackAPIUrl + '/v1/names/aaron.id');
    }).then(function (resp) {
      return resp.json();
    }).then(function (nameInfo) {
      t.equal(myNet.coerceAddress(nameInfo.address), transferDestination, 'aaron.id should be owned by ' + transferDestination);
    }).then(function () {
      return _lib.transactions.makeRenewal('aaron.id', renewalDestination, secondOwner, payer, renewalZF);
    }).then(function (rawtx) {
      return myNet.broadcastTransaction(rawtx);
    }).then(function () {
      console.log('RENEWAL broadcasted, waiting 30 seconds.');
      return new Promise(function (resolve) {
        return setTimeout(resolve, 30000);
      });
    }).then(function () {
      return myNet.broadcastZoneFile(renewalZF);
    }).then(function () {
      return fetch(myNet.blockstackAPIUrl + '/v1/names/aaron.id');
    }).then(function (resp) {
      return resp.json();
    }).then(function (nameInfo) {
      t.equal(nameInfo.zonefile, renewalZF, 'zonefile should be updated');
      t.equal(myNet.coerceAddress(nameInfo.address), renewalDestination, 'aaron.id should be owned by ' + renewalDestination);
    }).then(function () {
      return _lib.transactions.makeBitcoinSpend(btcDestAddress, payer, 500000);
    }).then(function (rawtx) {
      return myNet.broadcastTransaction(rawtx);
    }).then(function () {
      console.log('broadcasted SPEND, waiting 10 seconds.');
      return new Promise(function (resolve) {
        return setTimeout(resolve, 30000);
      });
    }).then(function () {
      return myNet.getUTXOs(btcDestAddress);
    }).then(function (utxos) {
      t.equal(utxos.length, 1, 'Destination address ' + btcDestAddress + ' should have 1 UTXO');
      var satoshis = utxos.reduce(function (agg, utxo) {
        return agg + utxo.value;
      }, 0);
      console.log(btcDestAddress + ' has ' + satoshis + ' satoshis');
    }).then(function () {
      return shutdownBlockstackCore();
    });
  });
}