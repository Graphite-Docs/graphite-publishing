'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.runOperationsTests = runOperationsTests;

var _tape = require('tape');

var _tape2 = _interopRequireDefault(_tape);

var _fetchMock = require('fetch-mock');

var _fetchMock2 = _interopRequireDefault(_fetchMock);

var _bitcoinjsLib = require('bitcoinjs-lib');

var _bitcoinjsLib2 = _interopRequireDefault(_bitcoinjsLib);

var _nock = require('nock');

var _nock2 = _interopRequireDefault(_nock);

var _network = require('../../../lib/network');

var _utils = require('../../../lib/operations/utils');

var _lib = require('../../../lib/');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var testAddresses = [{ skHex: '85b33fdfa5efeca980806c6ad3c8a55d67a850bd987237e7d49c967566346fbd01',
  address: '1br553PVnK6F5nyBtb4ju1owwBKdsep5c' }, { skHex: '744196d67ed78fe39009c71fbfd53e6ecca98353fbfe81ccba21b0703a69be9c01',
  address: '16xVjkJ3nY62B9t9q3N9wY6hx1duAfwRZR' }, { address: '1HEjCcUjZXtbiDnCYviHLVZvSQsSZoDRFa',
  skHex: '12f90d1b9e34d8df56f0dc6754a97ab4a2eb962918c281b1b552162438e313c001' }];

function networkTests() {
  (0, _tape2.default)('insight-client', function (t) {
    t.plan(5);
    var mynet = new _network.InsightClient('https://utxo.tester.com');

    _fetchMock2.default.restore();

    _fetchMock2.default.get('https://bitcoinfees.earn.com/api/v1/fees/recommended', { fastestFee: 1000 });

    var txhashFound = 'txhash-found';
    var blockHash = 'block-hash';
    var txhashNotFound = 'txhash-not-found';

    _fetchMock2.default.get('https://utxo.tester.com/tx/' + txhashNotFound, { body: JSON.stringify({ message: 'error fetching transaction details',
        error: '-5: No information available about transaction' }),
      status: 400 });
    _fetchMock2.default.get('https://utxo.tester.com/tx/' + txhashFound, { blockHash: blockHash });
    _fetchMock2.default.get('https://utxo.tester.com/block/' + blockHash, { height: 300 });
    _fetchMock2.default.get('https://utxo.tester.com/addr/' + testAddresses[0].address + '/utxo', [{ value: 1, satoshis: 1e8, confirmations: 2,
      txid: 'bar', vout: 10 }]);

    _fetchMock2.default.get('https://utxo.tester.com/status', { blocks: 500 });
    _fetchMock2.default.post('https://utxo.tester.com/tx/send', { body: 'true', status: 202 });

    mynet.broadcastTransaction('test-transaction-text').then(function (response) {
      t.ok(response, 'Should broadcast successfully');
    });

    mynet.getBlockHeight().then(function (response) {
      t.equal(response, 500, 'Should return block height');
    });

    mynet.getTransactionInfo(txhashNotFound).then(function () {
      return t.ok(false, 'Should not return txinfo for not-found transaction.');
    }).catch(function () {
      return t.ok(true, 'Should throw exception for not-found transaction.');
    });

    mynet.getTransactionInfo(txhashFound).then(function (txInfo) {
      return t.equal(txInfo.block_height, 300, 'Should return txinfo.block_height');
    }).catch(function () {
      return t.ok(false, 'Should not throw exception for a found transaction.');
    });

    mynet.getNetworkedUTXOs(testAddresses[0].address).then(function (utxos) {
      t.deepEqual(utxos, [{ value: 1e8, confirmations: 2, tx_hash: 'bar', tx_output_n: 10 }]);
    });
  });
}

function utilsTests() {
  (0, _tape2.default)('estimateTXBytes', function (t) {
    t.plan(2);
    var txHex = '010000000288e68977fab8038af07746e5d687652a44aa15f532509c202749d' + 'bad8a418733000000006b483045022100813ef3534b5030b544e5a5bd1db93f85dc89e2' + 'a565197a14784edff5564bd65b022008005213c6aa4c7ebe06cfd86bdaf3e662ae58371' + '896a0a841e81106fbe1507401210236b07942707a86ab666bb300b58d295d988ce9c3a3' + '38a0e08380dd98732fd4faffffffff3ba3edfd7a7b12b27ac72c3e67768f617fc81bc38' + '88a51323a9fb8aa4b1e5e4a000000006b483045022100d0c9b1594137186a1dc6c0b3a6' + 'cbe08399b57e2b8c953584f2ce20bef5642eb902206b9c88b8d2d311db26601acf3068d' + 'd118649ead4a1f93d029a52c0c61cb2cd2901210236b07942707a86ab666bb300b58d29' + '5d988ce9c3a338a0e08380dd98732fd4faffffffff030000000000000000296a2769643' + 'f363da95bc8d5203d1c07bd87c564a1e6395826cfdfe87cfd31ffa2a3b8101e3e93096f' + '2b7c150000000000001976a91441577ec99314a293acbc17d8152137cf4862f7f188ace' + '8030000000000001976a9142ebe7b4729185f68c7185c3c6af60fad1b6eeebf88ac00000000';
    var tx = _bitcoinjsLib2.default.Transaction.fromHex(txHex);
    tx.ins.forEach(function (x) {
      x.script = null;
    });

    var actualLength = txHex.length / 2;
    var estimatedLength = (0, _utils.estimateTXBytes)(tx, 0, 0);

    var tx2 = new _bitcoinjsLib2.default.TransactionBuilder();
    tx2.addOutput(tx.outs[0].script, 0);
    var estimatedLength2 = (0, _utils.estimateTXBytes)(tx2, 2, 2);

    t.ok(estimatedLength >= actualLength - 5 && estimatedLength <= actualLength + 5, 'TX size estimate is roughly accurate? (estimated: ' + estimatedLength + ',\n           actual: ' + actualLength + ')');
    t.ok(estimatedLength2 >= actualLength - 5 && estimatedLength2 <= actualLength + 5, 'TX size estimate is roughly accurate? (estimated: ' + estimatedLength2 + ',\n           actual: ' + actualLength + ')');
  });

  (0, _tape2.default)('encoding routines', function (t) {
    t.plan(5);

    t.equal((0, _utils.hash160)(Buffer.from('99999566ahjhqwuywqehpzlzlzlzl09189128921jkjlqjosq')).toString('hex'), '7ea1fa0f2003c31b015a72af9f4a5f104b5c2840');

    t.equal((0, _utils.hash160)(Buffer.from('1234')).toString('hex'), 'fd7a0d80999bedd76c9a0828057817fc6049a507');

    t.equal((0, _utils.hash128)(Buffer.from('999')).toString('hex'), '83cf8b609de60036a8277bd0e9613575');

    t.equal((0, _utils.hash128)(Buffer.from('99999566ahjhqwuywqehpzlzlzlzl09189128921jkjlqjosqaaa')).toString('hex'), '740ae7f18c939cf5e7c189a2c77a012f');

    t.equal((0, _utils.decodeB40)('0123456789abcdefghijklmnopqrstuvwxyz-_.+0123456789abcdefghi' + 'jklmnopqrstuvwxyz-_.+0123456789abcdefghijklmnopqrstuvwxyz-_' + '.+0123456789abcdefghijklmnopqrstuvwxyz-_.+0123456789abcdefg' + 'hijklmnopqrstuvwxyz-_.+'), '384a516059e707615a1992d3101f6f346df3326d03ea7b673e3754078895db48da2d0' + 'fcb1bd89d618b0863bd8bac6db43a2d9cff5cc307310922d3cb8cf9c159d31c6a9c91' + '03197263a4e88f52d1b77dfc610e1b8dc9616ba6c2d0a1b792f0d73784c698c69f34a' + 'e5e7900753627a3ac87529035fb1a6cba7ce2e1df590941cf30a44557');
  });

  (0, _tape2.default)('not enough UTXOs to fund', function (t) {
    t.plan(1);

    var txB = new _bitcoinjsLib2.default.TransactionBuilder();
    txB.addOutput(testAddresses[0].address, 10000);
    txB.addOutput(testAddresses[1].address, 0);

    var utxos = [{ value: 50000,
      tx_hash: '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b',
      tx_output_n: 0 }];

    t.throws(function () {
      return (0, _utils.addUTXOsToFund)(txB, utxos, 60000, 10);
    }, /^NotEnoughFundsError: Not enough UTXOs to fund./, 'Errors when not enough value to fund');
  });

  (0, _tape2.default)('addUTXOsToFundSingleUTXO', function (t) {
    t.plan(2);

    var txB = new _bitcoinjsLib2.default.TransactionBuilder();
    txB.addOutput(testAddresses[0].address, 10000);
    txB.addOutput(testAddresses[1].address, 0);

    var utxos = [{ value: 50000,
      tx_hash: '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b',
      tx_output_n: 0 }];

    var change = (0, _utils.addUTXOsToFund)(txB, utxos, 10000, 10);

    t.equal(change, 38520); // gots to pay the fee!
    t.equal(txB.tx.ins[0].hash.toString('hex'), Buffer.from(utxos[0].tx_hash, 'hex').reverse().toString('hex'));
  });

  (0, _tape2.default)('addUTXOsToFundTwoUTXOs', function (t) {
    t.plan(3);

    var txB = new _bitcoinjsLib2.default.TransactionBuilder();
    txB.addOutput(testAddresses[0].address, 10000);
    txB.addOutput(testAddresses[1].address, 0);

    var utxos = [{ value: 50000,
      tx_hash: '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b',
      tx_output_n: 0 }, { value: 10000,
      tx_hash: '3387418aaddb4927209c5032f515aa442a6587d6e54677f08a03b8fa7789e688',
      tx_output_n: 0 }];

    var change = (0, _utils.addUTXOsToFund)(txB, utxos, 55000, 10);

    t.ok(change <= 5000, txB.tx.outs[1].value + ' should be less than 5k');
    t.equal(txB.tx.ins[0].hash.toString('hex'), Buffer.from(utxos[0].tx_hash, 'hex').reverse().toString('hex'));
    t.equal(txB.tx.ins[1].hash.toString('hex'), Buffer.from(utxos[1].tx_hash, 'hex').reverse().toString('hex'));
  });

  (0, _tape2.default)('modifiedTXSets', function (t) {
    t.plan(11);
    var txStarterHex = '01000000013ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323' + 'a9fb8aa4b1e5e4a000000006a473044022050176492b92c79ba' + '23fb815e62a7778ccb45a50ca11b8dabdbadc1828e6ba34002200ce770' + '82a072eba8d3ce49e6a316e6173c1f97d955064574fe620cc25002eadb' + '01210236b07942707a86ab666bb300b58d295d988ce9c3a338a0e08380' + 'dd98732fd4faffffffff030000000000000000296a2769643f363da95b' + 'c8d5203d1c07bd87c564a1e6395826cfdfe87cfd31ffa2a3b8101e3e93' + '096f2be02c0000000000001976a91441577ec99314a293acbc17d81521' + '37cf4862f7f188ac39050000000000001976a9142ebe7b4729185f68c7' + '185c3c6af60fad1b6eeebf88ac00000000';

    var txStarter = _bitcoinjsLib2.default.Transaction.fromHex(txStarterHex);

    var txHash = '22a024f16944d2f568de4a613566fcfab53b86d37f1903668d399f9a366883de';

    t.equal(txStarter.getHash().reverse().toString('hex'), txHash);

    var usedTXHash = '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b';
    var utxoValues = [287825, 287825];
    var utxoSet1 = [{ value: utxoValues[0],
      tx_hash_big_endian: usedTXHash,
      tx_output_n: 0 }, { value: utxoValues[1],
      tx_hash_big_endian: '3387418aaddb4927209c5032f515aa442a6587d6e54677f08a03b8fa7789e688',
      tx_output_n: 0 }];
    var utxoSet2 = [];

    _lib.config.network.modifyUTXOSetFrom(txStarterHex);

    var testAddress1 = '16xVjkJ3nY62B9t9q3N9wY6hx1duAfwRZR';
    var testAddress2 = '15GAGiT2j2F1EzZrvjk3B8vBCfwVEzQaZx';

    _fetchMock2.default.restore();

    _fetchMock2.default.get('https://bitcoinfees.earn.com/api/v1/fees/recommended', { fastestFee: 1000 });

    _fetchMock2.default.get('https://blockchain.info/unspent?format=json&active=' + testAddress1 + '&cors=true', { unspent_outputs: utxoSet1 });
    _fetchMock2.default.get('https://blockchain.info/unspent?format=json&active=' + testAddress2 + '&cors=true', { unspent_outputs: utxoSet2 });

    Promise.all([_lib.config.network.getUTXOs(testAddress1), _lib.config.network.getUTXOs(testAddress2)]).then(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          utxos1 = _ref2[0],
          utxos2 = _ref2[1];

      t.equal(utxos1.length, 2);
      t.equal(utxos2.length, 1);
      t.ok(utxos1.find(function (x) {
        return x.tx_hash === txHash && x.value === 11488;
      }), 'UTXO set should include the new transaction\'s outputs');
      t.ok(utxos2.find(function (x) {
        return x.tx_hash === txHash && x.value === 1337;
      }), 'UTXO set should include the new transaction\'s outputs');
      t.ok(!utxos1.find(function (x) {
        return x.tx_hash === usedTXHash;
      }), 'UTXO set shouldn\'t include the transaction\'s spent input');
    }).then(function () {
      _lib.config.network.resetUTXOs(testAddress1);
      _lib.config.network.resetUTXOs(testAddress2);
      return Promise.all([_lib.config.network.getUTXOs(testAddress1), _lib.config.network.getUTXOs(testAddress2)]);
    }).then(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          utxos1 = _ref4[0],
          utxos2 = _ref4[1];

      t.equal(utxos1.length, 2);
      t.equal(utxos2.length, 0);
      t.ok(!utxos1.find(function (x) {
        return x.tx_hash === txHash && x.value === 11488;
      }), 'UTXO set should not include the new transaction\'s outputs after reset');
      t.ok(!utxos2.find(function (x) {
        return x.tx_hash === txHash && x.value === 1337;
      }), 'UTXO set should not include the new transaction\'s outputs after reset');
      t.ok(utxos1.find(function (x) {
        return x.tx_hash === usedTXHash;
      }), 'UTXO set should include the transaction\'s input after reset');
    });
  });
}

function transactionTests() {
  var utxoValues = [288000, 287825, 287825];
  var BURN_AMT = 6500;
  var BURN_ADDR = '15GAGiT2j2F1EzZrvjk3B8vBCfwVEzQaZx';

  var utxoSet = [{ value: utxoValues[0],
    tx_hash_big_endian: '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b',
    tx_output_n: 0 }, { value: utxoValues[1],
    tx_hash_big_endian: '3387418aaddb4927209c5032f515aa442a6587d6e54677f08a03b8fa7789e688',
    tx_output_n: 0 }, { value: utxoValues[2],
    tx_hash_big_endian: 'ffffffffffdb4927209c5032f515aa442a6587d6e54677f08a03b8fa7789e688',
    tx_output_n: 2 }];

  var utxoSet2 = [{ value: 5500,
    tx_hash_big_endian: 'ffffffffaab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdedffff',
    tx_output_n: 0 }];

  function setupMocks() {
    _fetchMock2.default.restore();
    _fetchMock2.default.get('https://bitcoinfees.earn.com/api/v1/fees/recommended', { fastestFee: 1000 });
    _fetchMock2.default.get('https://blockchain.info/unspent?format=json&active=' + testAddresses[1].address + '&cors=true', { unspent_outputs: utxoSet });
    _fetchMock2.default.get('https://blockchain.info/unspent?format=json&active=' + testAddresses[0].address + '&cors=true', { unspent_outputs: utxoSet2 });
    _fetchMock2.default.get('https://core.blockstack.org/v1/prices/names/foo.test', { name_price: { satoshis: BURN_AMT } });
    _fetchMock2.default.get('https://core.blockstack.org/v1/namespaces/test', { history: { 10: [{ burn_address: BURN_ADDR }] } });
    _fetchMock2.default.get('https://core.blockstack.org/v1/blockchains/bitcoin/consensus', { consensus_hash: 'dfe87cfd31ffa2a3b8101e3e93096f2b' });
  }

  function getInputVals(inputTXArgument) {
    var utxosAll = utxoSet.concat();
    return inputTXArgument.ins.reduce(function (agg, x) {
      var inputTX = utxosAll.find(function (y) {
        return Buffer.from(y.tx_hash_big_endian, 'hex').reverse().compare(x.hash) === 0;
      });
      if (inputTX) {
        return agg + inputTX.value;
      } else {
        return agg;
      }
    }, 0);
  }

  (0, _tape2.default)('build and fund preorder', function (t) {
    t.plan(6);
    setupMocks();

    Promise.all([_lib.transactions.estimatePreorder('foo.test', testAddresses[0].address, testAddresses[1].address), _lib.transactions.makePreorder('foo.test', testAddresses[0].address, testAddresses[1].skHex)]).then(function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 2),
          estimatedCost = _ref6[0],
          hexTX = _ref6[1];

      t.ok(hexTX);
      var tx = _bitcoinjsLib2.default.Transaction.fromHex(hexTX);
      var txLen = hexTX.length / 2;
      var outputVals = (0, _utils.sumOutputValues)(tx);
      var inputVals = getInputVals(tx);
      var fee = inputVals - outputVals;
      var burnAddress = _bitcoinjsLib2.default.address.fromOutputScript(tx.outs[2].script);

      var change = tx.outs[1].value;

      t.equal(inputVals - change, estimatedCost - 5500, 'Estimated cost should be +DUST_MINIMUM of actual.');
      t.equal(burnAddress, BURN_ADDR, 'Burn address should be ' + BURN_ADDR);
      t.equal(tx.outs[2].value, BURN_AMT, 'Output should have funded name price ' + BURN_AMT);
      t.equal(tx.ins.length, 1, 'Should use 1 utxo for the payer');
      t.ok(Math.floor(fee / txLen) > 990 && Math.floor(fee / txLen) < 1010, 'Paid fee of ' + fee + ' for tx of length ' + txLen + ' should equal 1k satoshi/byte');
    }).catch(function (err) {
      console.log(err.stack);throw err;
    });
  });

  (0, _tape2.default)('build and fund register', function (t) {
    t.plan(4);
    setupMocks();

    Promise.all([_lib.transactions.estimateRegister('foo.test', testAddresses[0].address, testAddresses[1].address, true, 2), _lib.transactions.makeRegister('foo.test', testAddresses[0].address, testAddresses[1].skHex, 'hello world')]).then(function (_ref7) {
      var _ref8 = _slicedToArray(_ref7, 2),
          estimatedCost = _ref8[0],
          hexTX = _ref8[1];

      var tx = _bitcoinjsLib2.default.Transaction.fromHex(hexTX);
      var txLen = hexTX.length / 2;
      var outputVals = (0, _utils.sumOutputValues)(tx);
      var inputVals = getInputVals(tx);
      var fee = inputVals - outputVals;

      // change address is the 3rd output usually...
      var change = tx.outs[2].value;

      t.equal(_bitcoinjsLib2.default.address.fromOutputScript(tx.outs[2].script), testAddresses[1].address, 'Payer change should be third output');
      t.equal(inputVals - change, estimatedCost, 'Estimated cost should match actual.');
      t.equal(tx.ins.length, 2, 'Should use both payer utxos');
      t.equal(Math.floor(fee / txLen), 1000, 'Paid fee of ' + fee + ' for tx of length ' + txLen + ' should equal 1k satoshi/byte');
    }).catch(function (err) {
      console.log(err.stack);throw err;
    });
  });

  (0, _tape2.default)('build and fund update', function (t) {
    t.plan(5);
    setupMocks();

    Promise.all([_lib.transactions.estimateUpdate('foo.test', testAddresses[0].address, testAddresses[1].address, 3), _lib.transactions.makeUpdate('foo.test', testAddresses[0].skHex, testAddresses[1].skHex, 'hello world')]).then(function (_ref9) {
      var _ref10 = _slicedToArray(_ref9, 2),
          estimatedCost = _ref10[0],
          hexTX = _ref10[1];

      var tx = _bitcoinjsLib2.default.Transaction.fromHex(hexTX);
      var txLen = hexTX.length / 2;
      var outputVals = (0, _utils.sumOutputValues)(tx);
      var inputVals = getInputVals(tx);
      var fee = inputVals - outputVals;

      // payer change address is the 3rd output...
      var changeOut = tx.outs[2];
      var ownerChange = tx.outs[1];
      var change = changeOut.value;

      t.equal(_bitcoinjsLib2.default.address.fromOutputScript(changeOut.script), testAddresses[1].address, 'Owner change should be second output');
      t.equal(_bitcoinjsLib2.default.address.fromOutputScript(ownerChange.script), testAddresses[0].address, 'Payer change should be third output');
      t.equal(inputVals - change, estimatedCost, 'Estimated cost should match actual.');
      t.equal(tx.ins.length, 4, 'Should use all payer utxos and one owner utxo');
      t.ok(Math.floor(fee / txLen) > 990 && Math.floor(fee / txLen) < 1010, 'Paid fee of ' + fee + ' for tx of length ' + txLen + ' should roughly equal 1k satoshi/byte');
    }).catch(function (err) {
      console.log(err.stack);throw err;
    });
  });

  (0, _tape2.default)('build and fund transfer', function (t) {
    t.plan(6);
    setupMocks();

    Promise.all([_lib.transactions.estimateTransfer('foo.test', testAddresses[2].address, testAddresses[0].address, testAddresses[1].address, 3), _lib.transactions.makeTransfer('foo.test', testAddresses[2].address, testAddresses[0].skHex, testAddresses[1].skHex)]).then(function (_ref11) {
      var _ref12 = _slicedToArray(_ref11, 2),
          estimatedCost = _ref12[0],
          hexTX = _ref12[1];

      var tx = _bitcoinjsLib2.default.Transaction.fromHex(hexTX);
      var txLen = hexTX.length / 2;
      var outputVals = (0, _utils.sumOutputValues)(tx);
      var inputVals = getInputVals(tx);
      var fee = inputVals - outputVals;

      // payer change address is the 4th output...
      var changeOut = tx.outs[3];
      // old owner change address is the 3rd output
      var ownerChange = tx.outs[2];

      var change = changeOut.value;

      t.equal(_bitcoinjsLib2.default.address.fromOutputScript(tx.outs[1].script), testAddresses[2].address, 'New owner should be second output');
      t.equal(_bitcoinjsLib2.default.address.fromOutputScript(ownerChange.script), testAddresses[0].address, 'Prior owner should be third output');
      t.equal(_bitcoinjsLib2.default.address.fromOutputScript(changeOut.script), testAddresses[1].address, 'Payer change should be fourth output');
      t.equal(inputVals - change, estimatedCost, 'Estimated cost should match actual.');
      t.equal(tx.ins.length, 4, 'Should use both payer utxos and one owner utxo');
      t.ok(Math.floor(fee / txLen) > 990 && Math.floor(fee / txLen) < 1010, 'Paid fee of ' + fee + ' for tx of length ' + txLen + ' should roughly equal 1k satoshi/byte');
    }).catch(function (err) {
      console.log(err.stack);throw err;
    });
  });

  (0, _tape2.default)('fund bitcoin spends', function (t) {
    t.plan(14);
    setupMocks();
    var TEST1_AMOUNT = 250000;
    var TEST2_AMOUNT = 80000;
    var TEST3_AMOUNT = 288000 + 287825 + 287825;
    var TEST4_AMOUNT = 288000 + 287825 + 287825 + 1;
    _lib.transactions.makeBitcoinSpend(testAddresses[2].address, testAddresses[1].skHex, TEST1_AMOUNT).then(function (hexTX) {
      var tx = _bitcoinjsLib2.default.Transaction.fromHex(hexTX);
      var txLen = hexTX.length / 2;
      var outputVals = (0, _utils.sumOutputValues)(tx);
      var inputVals = getInputVals(tx);
      var fee = inputVals - outputVals;
      t.equal(tx.ins.length, 1, 'Should use 1 input');
      t.equal(tx.outs.length, 2, 'Should have a change output');
      var changeOut = tx.outs[1];
      t.equal(_bitcoinjsLib2.default.address.fromOutputScript(changeOut.script), testAddresses[1].address, 'Must be correct change address');
      t.ok(Math.abs(1000 * txLen - fee) <= 2000, 'Fee should be roughly correct: Actual fee: ' + fee + ', expected: ' + 1000 * txLen);
      t.equal(inputVals - changeOut.value, TEST1_AMOUNT, 'Should fund correct amount');
    }).then(function () {
      return _lib.transactions.makeBitcoinSpend(testAddresses[2].address, testAddresses[1].skHex, TEST2_AMOUNT);
    }).then(function () {
      return t.fail('Should reject with InvalidAmountError if not enough coin to fund fees.');
    }).catch(function (err) {
      return t.equal(err.name, 'InvalidAmountError', 'Should reject with InvalidAmountError if not enough coin to fund fees.');
    }).then(function () {
      return _lib.transactions.makeBitcoinSpend(testAddresses[2].address, testAddresses[1].skHex, TEST3_AMOUNT);
    }).then(function (hexTX) {
      var tx = _bitcoinjsLib2.default.Transaction.fromHex(hexTX);
      var txLen = hexTX.length / 2;
      var outputVals = (0, _utils.sumOutputValues)(tx);
      var inputVals = getInputVals(tx);
      var fee = inputVals - outputVals;
      t.equal(tx.ins.length, 3, 'Should use 3 inputs');
      t.equal(tx.outs.length, 1, 'Should not have a change output');
      t.ok(Math.abs(1000 * txLen - fee) <= 2000, 'Fee should be roughly correct.');
      t.equal(outputVals + fee, TEST3_AMOUNT, 'Should fund correct amount');
    }).then(function () {
      return _lib.transactions.makeBitcoinSpend(testAddresses[2].address, testAddresses[1].skHex, TEST4_AMOUNT);
    }).then(function (hexTX) {
      var tx = _bitcoinjsLib2.default.Transaction.fromHex(hexTX);
      var txLen = hexTX.length / 2;
      var outputVals = (0, _utils.sumOutputValues)(tx);
      var inputVals = getInputVals(tx);
      var fee = inputVals - outputVals;
      t.equal(tx.ins.length, 3, 'Should use 3 inputs');
      t.equal(tx.outs.length, 1, 'Should not have a change output');
      t.ok(Math.abs(1000 * txLen - fee) <= 2000, 'Fee should be roughly correct.');
      t.equal(outputVals + fee, TEST3_AMOUNT, 'Should fund maximum amount');
    });
  });

  (0, _tape2.default)('build and fund renewal', function (t) {
    t.plan(7);
    setupMocks();

    Promise.all([_lib.transactions.estimateRenewal('foo.test', testAddresses[2].address, testAddresses[0].address, testAddresses[1].address, true, 3), _lib.transactions.makeRenewal('foo.test', testAddresses[2].address, testAddresses[0].skHex, testAddresses[1].skHex, 'hello world')]).then(function (_ref13) {
      var _ref14 = _slicedToArray(_ref13, 2),
          estimatedCost = _ref14[0],
          hexTX = _ref14[1];

      var tx = _bitcoinjsLib2.default.Transaction.fromHex(hexTX);
      var txLen = hexTX.length / 2;
      var outputVals = (0, _utils.sumOutputValues)(tx);
      var inputVals = getInputVals(tx);
      var fee = inputVals - outputVals;

      // payer change address is the 5th output...
      var changeOut = tx.outs[4];
      // old owner change address is the 3rd output
      var ownerChange = tx.outs[2];

      var change = changeOut.value;

      t.equal(_bitcoinjsLib2.default.address.fromOutputScript(tx.outs[1].script), testAddresses[2].address, 'New owner should be second output');
      t.equal(_bitcoinjsLib2.default.address.fromOutputScript(ownerChange.script), testAddresses[0].address, 'Prior owner should be third output');
      t.equal(_bitcoinjsLib2.default.address.fromOutputScript(tx.outs[3].script), BURN_ADDR, 'Burn address should be fourth output');
      t.equal(_bitcoinjsLib2.default.address.fromOutputScript(changeOut.script), testAddresses[1].address, 'Payer change should be fifth output');
      t.equal(inputVals - change, estimatedCost, 'Estimated cost should be accurate.');
      t.equal(tx.ins.length, 4, 'Should use both payer utxos and one owner utxo');
      t.ok(Math.floor(fee / txLen) > 990 && Math.floor(fee / txLen) < 1010, 'Paid fee of ' + fee + ' for tx of length ' + txLen + ' should roughly equal 1k satoshi/byte');
    }).catch(function (err) {
      console.log(err.stack);throw err;
    });
  });

  (0, _tape2.default)('broadcastTransaction:\n    send via broadcast service with transaction to watch with default confs', function (t) {
    t.plan(1);
    _fetchMock2.default.restore();
    var transaction = 'abc';
    var transactionToWatch = '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b';
    var confirmations = 6;
    _nock2.default.cleanAll();
    (0, _nock2.default)('https://broadcast.blockstack.org').post('/v1/broadcast/transaction', {
      transaction: transaction,
      transactionToWatch: transactionToWatch,
      confirmations: confirmations
    }).once().reply(202, {});

    _network.network.defaults.MAINNET_DEFAULT.broadcastTransaction(transaction, transactionToWatch).then(function () {
      t.assert(_nock2.default.isDone());
    });
  });

  (0, _tape2.default)('broadcastTransaction:\n    rejects with error when broadcast service has a problem', function (t) {
    t.plan(3);
    _fetchMock2.default.restore();
    var transaction = 'abc';
    var transactionToWatch = '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b';
    var confirmations = 6;
    _nock2.default.cleanAll();
    (0, _nock2.default)('https://broadcast.blockstack.org').post('/v1/broadcast/transaction', {
      transaction: transaction,
      transactionToWatch: transactionToWatch,
      confirmations: confirmations
    }).once().reply(500, {});

    _network.network.defaults.MAINNET_DEFAULT.broadcastTransaction(transaction, transactionToWatch).catch(function (error) {
      t.assert(_nock2.default.isDone());
      t.assert(error.response);
      t.equal(error.code, 'remote_service_error');
    });
  });

  (0, _tape2.default)('broadcastTransaction:\n    send via broadcast service with transaction to watch with custom confs', function (t) {
    t.plan(1);
    _fetchMock2.default.restore();
    var transaction = 'abc';
    var transactionToWatch = '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b';
    var confirmations = 8;
    _nock2.default.cleanAll();
    (0, _nock2.default)('https://broadcast.blockstack.org').post('/v1/broadcast/transaction', {
      transaction: transaction,
      transactionToWatch: transactionToWatch,
      confirmations: confirmations
    }).once().reply(202, {});

    _network.network.defaults.MAINNET_DEFAULT.broadcastTransaction(transaction, transactionToWatch, confirmations).then(function () {
      t.assert(_nock2.default.isDone());
    });
  });

  (0, _tape2.default)('broadcastTransaction: send immediately via utxo service', function (t) {
    t.plan(1);
    _fetchMock2.default.restore();
    var transaction = '01000000010470c3139dc0f0882f98d75ae5bf957e68da' + 'dd32c5f81261c0b13e85f592ff7b0000000000ffffffff02b286a61e00000000' + '1976a9140f39a0043cf7bdbe429c17e8b514599e9ec53dea88ac010000000000' + '00001976a9148a8c9fd79173f90cf76410615d2a52d12d27d21288ac00000000';
    _nock2.default.cleanAll();
    (0, _nock2.default)('https://blockchain.info').post('/pushtx?cors=true', function (body) {
      return body.includes(transaction);
    }).once().reply(202, 'transaction submitted');

    _network.network.defaults.MAINNET_DEFAULT.broadcastTransaction(transaction).then(function () {
      t.assert(_nock2.default.isDone());
    });
  });

  (0, _tape2.default)('broadcastTransaction: rejects with error when utxo provider has a problem', function (t) {
    t.plan(3);
    _fetchMock2.default.restore();
    var transaction = '01000000010470c3139dc0f0882f98d75ae5bf957e68da' + 'dd32c5f81261c0b13e85f592ff7b0000000000ffffffff02b286a61e00000000' + '1976a9140f39a0043cf7bdbe429c17e8b514599e9ec53dea88ac010000000000' + '00001976a9148a8c9fd79173f90cf76410615d2a52d12d27d21288ac00000000';
    _nock2.default.cleanAll();
    (0, _nock2.default)('https://blockchain.info').post('/pushtx?cors=true', function (body) {
      return body.includes(transaction);
    }).once().reply(500, 'something else');

    _network.network.defaults.MAINNET_DEFAULT.broadcastTransaction(transaction).catch(function (error) {
      t.assert(_nock2.default.isDone());
      t.assert(error.response);
      t.equal(error.code, 'remote_service_error');
    });
  });

  (0, _tape2.default)('broadcastZoneFile: send via broadcast service with transaction to watch', function (t) {
    t.plan(1);
    _fetchMock2.default.restore();
    var zoneFile = '$ORIGIN satoshi.id\n$TTL 3600\n_http._tcp	IN	URI	10	1	"https://example.com/satoshi.json"\n\n';
    var transactionToWatch = '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b';

    _nock2.default.cleanAll();
    (0, _nock2.default)('https://broadcast.blockstack.org').post('/v1/broadcast/zone-file', {
      zoneFile: zoneFile,
      transactionToWatch: transactionToWatch
    }).once().reply(202, {});

    _network.network.defaults.MAINNET_DEFAULT.broadcastZoneFile(zoneFile, transactionToWatch).then(function () {
      t.assert(_nock2.default.isDone());
    });
  });

  (0, _tape2.default)('broadcastZoneFile: rejects with error if broadcast service error', function (t) {
    t.plan(3);
    _fetchMock2.default.restore();
    var zoneFile = '$ORIGIN satoshi.id\n$TTL 3600\n_http._tcp	IN	URI	10	1	"https://example.com/satoshi.json"\n\n';
    var transactionToWatch = '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b';

    _nock2.default.cleanAll();
    (0, _nock2.default)('https://broadcast.blockstack.org').post('/v1/broadcast/zone-file', {
      zoneFile: zoneFile,
      transactionToWatch: transactionToWatch
    }).once().reply(500, {});

    _network.network.defaults.MAINNET_DEFAULT.broadcastZoneFile(zoneFile, transactionToWatch).catch(function (error) {
      t.assert(_nock2.default.isDone());
      t.assert(error.response);
      t.equal(error.code, 'remote_service_error');
    });
  });

  (0, _tape2.default)('broadcastZoneFile: rejects with error if core endpoint error', function (t) {
    t.plan(3);
    _fetchMock2.default.restore();
    var zoneFile = '$ORIGIN satoshi.id\n$TTL 3600\n_http._tcp	IN	URI	10	1	"https://example.com/satoshi.json"\n\n';

    _nock2.default.cleanAll();
    (0, _nock2.default)('https://core.blockstack.org').post('/v1/zonefile/', {
      zonefile: zoneFile
    }).once().reply(200, { error: 'core indicates an error like this' });
    _network.network.defaults.MAINNET_DEFAULT.broadcastZoneFile(zoneFile).catch(function (error) {
      t.assert(_nock2.default.isDone());
      t.assert(error.response);
      t.equal(error.code, 'remote_service_error');
    });
  });

  (0, _tape2.default)('broadcastZoneFile: send immediately via core atlas endpoint', function (t) {
    t.plan(1);
    _fetchMock2.default.restore();
    var zoneFile = '$ORIGIN satoshi.id\n$TTL 3600\n_http._tcp	IN	URI	10	1	"https://example.com/satoshi.json"\n\n';

    _nock2.default.cleanAll();
    (0, _nock2.default)('https://core.blockstack.org').post('/v1/zonefile/', {
      zonefile: zoneFile
    }).once().reply(202, {});

    _network.network.defaults.MAINNET_DEFAULT.broadcastZoneFile(zoneFile).then(function () {
      t.assert(_nock2.default.isDone());
    });
  });

  (0, _tape2.default)('broadcastZoneFile: rejects with missing parameter error when\n     zone file not provided', function (t) {
    t.plan(2);
    _fetchMock2.default.restore();
    _nock2.default.cleanAll();

    _network.network.defaults.MAINNET_DEFAULT.broadcastZoneFile().catch(function (error) {
      t.assert(error);
      t.equal(error.code, 'missing_parameter');
    });
  });

  (0, _tape2.default)('broadcastNameRegistration', function (t) {
    t.plan(1);
    _fetchMock2.default.restore();
    var zoneFile = '$ORIGIN satoshi.id\n$TTL 3600\n_http._tcp	IN	URI	10	1	"https://example.com/satoshi.json"\n\n';
    var preorderTransaction = 'abc';
    var registerTransaction = '123';

    _nock2.default.cleanAll();
    (0, _nock2.default)('https://broadcast.blockstack.org').post('/v1/broadcast/registration', {
      preorderTransaction: preorderTransaction,
      registerTransaction: registerTransaction,
      zoneFile: zoneFile
    }).once().reply(202, {});

    _network.network.defaults.MAINNET_DEFAULT.broadcastNameRegistration(preorderTransaction, registerTransaction, zoneFile).then(function () {
      t.assert(_nock2.default.isDone());
    });
  });

  (0, _tape2.default)('broadcastNameRegistration: reject with error if service replies with error', function (t) {
    t.plan(3);
    _fetchMock2.default.restore();
    var zoneFile = '$ORIGIN satoshi.id\n$TTL 3600\n_http._tcp	IN	URI	10	1	"https://example.com/satoshi.json"\n\n';
    var preorderTransaction = 'abc';
    var registerTransaction = '123';

    _nock2.default.cleanAll();
    (0, _nock2.default)('https://broadcast.blockstack.org').post('/v1/broadcast/registration', {
      preorderTransaction: preorderTransaction,
      registerTransaction: registerTransaction,
      zoneFile: zoneFile
    }).once().reply(500, {});

    _network.network.defaults.MAINNET_DEFAULT.broadcastNameRegistration(preorderTransaction, registerTransaction, zoneFile).catch(function (error) {
      t.assert(error);
      t.assert(error.response);
      t.equal(error.code, 'remote_service_error');
    });
  });

  (0, _tape2.default)('broadcastNameRegistration: reject with error\n    when transactions or zoneFile not provided', function (t) {
    var zoneFile = '$ORIGIN satoshi.id\n$TTL 3600\n_http._tcp	IN	URI	10	1	"https://example.com/satoshi.json"\n\n';
    var preorderTransaction = 'abc';
    var registerTransaction = '123';
    t.plan(9);
    _fetchMock2.default.restore();
    _nock2.default.cleanAll();

    _network.network.defaults.MAINNET_DEFAULT.broadcastNameRegistration(undefined, registerTransaction, zoneFile).catch(function (error) {
      t.assert(error);
      t.equal(error.code, 'missing_parameter');
      t.equal(error.parameter, 'preorderTransaction');
    });

    _network.network.defaults.MAINNET_DEFAULT.broadcastNameRegistration(preorderTransaction, undefined, zoneFile).catch(function (error) {
      t.assert(error);
      t.equal(error.code, 'missing_parameter');
      t.equal(error.parameter, 'registerTransaction');
    });

    _network.network.defaults.MAINNET_DEFAULT.broadcastNameRegistration(preorderTransaction, registerTransaction, undefined).catch(function (error) {
      t.assert(error);
      t.equal(error.code, 'missing_parameter');
      t.equal(error.parameter, 'zoneFile');
    });
  });
}

function safetyTests() {
  (0, _tape2.default)('addCanReceiveName', function (t) {
    t.plan(2);
    _fetchMock2.default.restore();
    _fetchMock2.default.get('https://core.blockstack.org/v1/addresses/bitcoin/' + testAddresses[1].address, { names: ['dummy.id', 'dummy.id', 'dummy.id'] });
    var namesTooMany = new Array(25);
    namesTooMany.fill('dummy.id');
    _fetchMock2.default.get('https://core.blockstack.org/v1/addresses/bitcoin/' + testAddresses[0].address, { names: namesTooMany });

    Promise.all([_lib.safety.addressCanReceiveName(testAddresses[0].address), _lib.safety.addressCanReceiveName(testAddresses[1].address)]).then(function (_ref15) {
      var _ref16 = _slicedToArray(_ref15, 2),
          t0 = _ref16[0],
          t1 = _ref16[1];

      t.ok(t1, 'Test address ${testAddresses[1].address} should not have too many names.');
      t.ok(!t0, 'Test address ${testAddresses[0].address} should have too many names.');
    });
  });

  (0, _tape2.default)('ownsName', function (t) {
    t.plan(2);
    _fetchMock2.default.restore();
    _fetchMock2.default.get('https://core.blockstack.org/v1/names/foo.test', { address: testAddresses[0].address });

    Promise.all([_lib.safety.ownsName('foo.test', testAddresses[0].address), _lib.safety.ownsName('foo.test', testAddresses[1].address)]).then(function (_ref17) {
      var _ref18 = _slicedToArray(_ref17, 2),
          t0 = _ref18[0],
          t1 = _ref18[1];

      t.ok(t0, 'Test address ${testAddresses[0].address} should own foo.test');
      t.ok(!t1, 'Test address ${testAddresses[1].address} should not own foo.test');
    });
  });

  (0, _tape2.default)('nameInGracePeriod', function (t) {
    t.plan(4);
    _fetchMock2.default.restore();

    _fetchMock2.default.get('https://core.blockstack.org/v1/names/bar.test', { body: 'Name available', status: 404 });
    _fetchMock2.default.get('https://core.blockstack.org/v1/names/foo.test', { expires_block: 50 });
    _fetchMock2.default.getOnce('https://blockchain.info/latestblock?cors=true', { height: 49 });
    _lib.safety.isInGracePeriod('foo.test').then(function (result) {
      t.ok(!result, 'name should not be in grace period if it isnt expired');
      _fetchMock2.default.getOnce('https://blockchain.info/latestblock?cors=true', { height: 50 });
      return _lib.safety.isInGracePeriod('foo.test');
    }).then(function (result) {
      t.ok(result, 'name should be in grace period');
      _fetchMock2.default.get('https://blockchain.info/latestblock?cors=true', { height: 5050 });
      return _lib.safety.isInGracePeriod('foo.test');
    }).then(function (result) {
      t.ok(!result, 'grace period should have passed');
      return _lib.safety.isInGracePeriod('bar.test');
    }).then(function (result) {
      t.ok(!result, 'bar.test isnt registered. not in grace period');
    }).catch(function (err) {
      return console.error(err.stack);
    });
  });

  (0, _tape2.default)('nameAvailable', function (t) {
    t.plan(2);
    _fetchMock2.default.restore();
    _fetchMock2.default.get('https://core.blockstack.org/v1/names/foo.test', { body: 'Name available', status: 404 });
    _fetchMock2.default.get('https://core.blockstack.org/v1/names/bar.test', { address: testAddresses[0].address });

    Promise.all([_lib.safety.isNameAvailable('foo.test'), _lib.safety.isNameAvailable('bar.test')]).then(function (_ref19) {
      var _ref20 = _slicedToArray(_ref19, 2),
          t0 = _ref20[0],
          t1 = _ref20[1];

      t.ok(t0, 'foo.test should be available');
      t.ok(!t1, 'bar.test isnt available');
    });
  });

  (0, _tape2.default)('nameValid', function (t) {
    t.plan(11);

    var shouldFail = [{ name: '123456789012345678901234567890.1234567',
      reason: 'is too long' }, { name: '1234567890123456789012345678901234567',
      reason: 'has no namespace' }, { name: '1.2.3',
      reason: 'is a subdomain' }, { name: null,
      reason: 'is null' }, { name: '.43',
      reason: 'has no name' }, { name: '43#43.xyz',
      reason: 'illegal character' }, { name: '43 43.xyz',
      reason: 'illegal character' }].map(function (x) {
      return _lib.safety.isNameValid(x.name).then(function (passed) {
        return t.ok(!passed, x.name + ' should fail for: ' + x.reason);
      });
    });

    var shouldPass = ['abc123.id', 'abcd123.1', '123456789012345678901234567890.123456', 'abc_+-123.id'].map(function (x) {
      return _lib.safety.isNameValid(x).then(function (passed) {
        return t.ok(passed, x + ' should pass');
      });
    });

    Promise.all(shouldPass).then(function () {
      return Promise.all(shouldFail);
    });
  });
}

function runOperationsTests() {
  networkTests();
  utilsTests();
  transactionTests();
  safetyTests();
}