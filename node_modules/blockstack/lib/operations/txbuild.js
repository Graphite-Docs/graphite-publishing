'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transactions = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _bitcoinjsLib = require('bitcoinjs-lib');

var _bitcoinjsLib2 = _interopRequireDefault(_bitcoinjsLib);

var _utils = require('./utils');

var _skeletons = require('./skeletons');

var _config = require('../config');

var _utils2 = require('../utils');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dummyBurnAddress = '1111111111111111111114oLvT2';
var dummyConsensusHash = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
var dummyZonefileHash = 'ffffffffffffffffffffffffffffffffffffffff';

function addOwnerInput(utxos, ownerAddress, txB) {
  var addChangeOut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  // add an owner UTXO and a change out.
  if (utxos.length < 0) {
    throw new Error('Owner has no UTXOs for UPDATE.');
  }

  utxos.sort(function (a, b) {
    return a.value - b.value;
  });
  var ownerUTXO = utxos[0];
  var ownerInput = txB.addInput(ownerUTXO.tx_hash, ownerUTXO.tx_output_n);
  if (addChangeOut) {
    txB.addOutput(ownerAddress, ownerUTXO.value);
  }
  return { index: ownerInput, value: ownerUTXO.value };
}

function fundTransaction(txB, paymentAddress, utxos, feeRate, inAmounts) {
  var changeIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

  // change index for the payer.
  if (changeIndex === null) {
    changeIndex = txB.addOutput(paymentAddress, _utils.DUST_MINIMUM);
  }
  // fund the transaction fee.
  var txFee = (0, _utils.estimateTXBytes)(txB, 0, 0) * feeRate;
  var outAmounts = (0, _utils.sumOutputValues)(txB);
  var change = (0, _utils.addUTXOsToFund)(txB, utxos, txFee + outAmounts - inAmounts, feeRate);
  txB.tx.outs[changeIndex].value += change;
  return txB;
}

/**
 * Estimates cost of a preorder transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to preorder
 * @param {String} destinationAddress - the address to receive the name (this
 *    must be passed as the 'registrationAddress' in the register transaction)
 * @param {String} paymentAddress - the address funding the preorder
 * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
 *    from the payment address.
 * @returns {Promise} - a promise which resolves to the satoshi cost to fund
 *    the preorder. This includes a 5500 satoshi dust output for the preorder.
 *    Even though this is a change output, the payer must supply enough funds
 *    to generate this output, so we include it in the cost.
 * @private
 */
function estimatePreorder(fullyQualifiedName, destinationAddress, paymentAddress) {
  var paymentUtxos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

  var network = _config.config.network;

  var preorderPromise = network.getNamePrice(fullyQualifiedName).then(function (namePrice) {
    return (0, _skeletons.makePreorderSkeleton)(fullyQualifiedName, dummyConsensusHash, paymentAddress, dummyBurnAddress, namePrice, destinationAddress);
  });

  return Promise.all([network.getFeeRate(), preorderPromise]).then(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        feeRate = _ref2[0],
        preorderTX = _ref2[1];

    var outputsValue = (0, _utils.sumOutputValues)(preorderTX);
    var txFee = feeRate * (0, _utils.estimateTXBytes)(preorderTX, paymentUtxos, 0);
    return txFee + outputsValue;
  });
}

/**
 * Estimates cost of a register transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to register
 * @param {String} registerAddress - the address to receive the name
 * @param {String} paymentAddress - the address funding the register
 * @param {Boolean} includingZonefile - whether or not we will broadcast
 *    a zonefile hash as part  of the register
 * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
 *    from the payment address.
 * @returns {Promise} - a promise which resolves to the satoshi cost to fund
 *    the register.
 * @private
 */
function estimateRegister(fullyQualifiedName, registerAddress, paymentAddress) {
  var includingZonefile = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var paymentUtxos = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;

  var network = _config.config.network;

  var valueHash = undefined;
  if (includingZonefile) {
    valueHash = dummyZonefileHash;
  }

  var registerTX = (0, _skeletons.makeRegisterSkeleton)(fullyQualifiedName, registerAddress, valueHash);

  return network.getFeeRate().then(function (feeRate) {
    var outputsValue = (0, _utils.sumOutputValues)(registerTX);
    // 1 additional output for payer change
    var txFee = feeRate * (0, _utils.estimateTXBytes)(registerTX, paymentUtxos, 1);
    return txFee + outputsValue;
  });
}

/**
 * Estimates cost of an update transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to update
 * @param {String} ownerAddress - the owner of the name
 * @param {String} paymentAddress - the address funding the update
 * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
 *    from the payment address.
 * @returns {Promise} - a promise which resolves to the satoshi cost to fund
 *    the update.
 * @private
 */
function estimateUpdate(fullyQualifiedName, ownerAddress, paymentAddress) {
  var paymentUtxos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

  var network = _config.config.network;

  var updateTX = (0, _skeletons.makeUpdateSkeleton)(fullyQualifiedName, dummyConsensusHash, dummyZonefileHash);

  return network.getFeeRate().then(function (feeRate) {
    var outputsValue = (0, _utils.sumOutputValues)(updateTX);
    // 1 additional input for the owner
    // 2 additional outputs for owner / payer change
    var txFee = feeRate * (0, _utils.estimateTXBytes)(updateTX, 1 + paymentUtxos, 2);
    return txFee + outputsValue;
  });
}

/**
 * Estimates cost of an transfer transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to transfer
 * @param {String} destinationAddress - the next owner of the name
 * @param {String} ownerAddress - the current owner of the name
 * @param {String} paymentAddress - the address funding the transfer
 * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
 *    from the payment address.
 * @returns {Promise} - a promise which resolves to the satoshi cost to fund
 *    the transfer.
 * @private
 */
function estimateTransfer(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress) {
  var paymentUtxos = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;

  var network = _config.config.network;

  var transferTX = (0, _skeletons.makeTransferSkeleton)(fullyQualifiedName, dummyConsensusHash, destinationAddress);

  return network.getFeeRate().then(function (feeRate) {
    var outputsValue = (0, _utils.sumOutputValues)(transferTX);
    // 1 additional input for the owner
    // 2 additional outputs for owner / payer change
    var txFee = feeRate * (0, _utils.estimateTXBytes)(transferTX, 1 + paymentUtxos, 2);
    return txFee + outputsValue;
  });
}

/**
 * Estimates cost of an transfer transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to renew
 * @param {String} destinationAddress - the next owner of the name
 * @param {String} ownerAddress - the current owner of the name
 * @param {String} paymentAddress - the address funding the transfer
 * @param {Boolean} includingZonefile - whether or not we will broadcast a zonefile hash
      in the renewal operation
 * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
 *    from the payment address.
 * @returns {Promise} - a promise which resolves to the satoshi cost to fund
 *    the transfer.
 * @private
 */
function estimateRenewal(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress) {
  var includingZonefile = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var paymentUtxos = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;

  var network = _config.config.network;

  var valueHash = undefined;
  if (includingZonefile) {
    valueHash = dummyZonefileHash;
  }

  var renewalPromise = network.getNamePrice(fullyQualifiedName).then(function (namePrice) {
    return (0, _skeletons.makeRenewalSkeleton)(fullyQualifiedName, destinationAddress, ownerAddress, dummyBurnAddress, namePrice, valueHash);
  });

  return Promise.all([network.getFeeRate(), renewalPromise]).then(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        feeRate = _ref4[0],
        renewalTX = _ref4[1];

    var outputsValue = (0, _utils.sumOutputValues)(renewalTX);
    // 1 additional input for the owner
    // and renewal skeleton includes all outputs for owner change, but not for payer change.
    var txFee = feeRate * (0, _utils.estimateTXBytes)(renewalTX, 1 + paymentUtxos, 1);
    return txFee + outputsValue - 5500; // don't count the dust change for old owner.
  });
}

/**
 * Generates a preorder transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to pre-order
 * @param {String} destinationAddress - the address to receive the name (this
 *    must be passed as the 'registrationAddress' in the register transaction)
 * @param {String} paymentKeyHex - a hex string of the private key used to
 *    fund the transaction
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 *    this function *does not* perform the requisite safety checks -- please see
 *    the safety module for those.
 * @private
 */
function makePreorder(fullyQualifiedName, destinationAddress, paymentKeyHex) {
  var network = _config.config.network;

  var namespace = fullyQualifiedName.split('.').pop();

  var paymentKey = (0, _utils2.hexStringToECPair)(paymentKeyHex);
  var preorderAddress = paymentKey.getAddress();

  var preorderPromise = Promise.all([network.getConsensusHash(), network.getNamePrice(fullyQualifiedName), network.getNamespaceBurnAddress(namespace)]).then(function (_ref5) {
    var _ref6 = _slicedToArray(_ref5, 3),
        consensusHash = _ref6[0],
        namePrice = _ref6[1],
        burnAddress = _ref6[2];

    return (0, _skeletons.makePreorderSkeleton)(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, namePrice, destinationAddress);
  });

  return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise]).then(function (_ref7) {
    var _ref8 = _slicedToArray(_ref7, 3),
        utxos = _ref8[0],
        feeRate = _ref8[1],
        preorderSkeleton = _ref8[2];

    var txB = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);

    var changeIndex = 1; // preorder skeleton always creates a change output at index = 1
    var signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);

    for (var i = 0; i < signingTxB.tx.ins.length; i++) {
      signingTxB.sign(i, paymentKey);
    }
    return signingTxB.build().toHex();
  });
}

/**
 * Generates an update transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to update
 * @param {String} ownerKeyHex - a hex string of the owner key. this will
 *    provide one UTXO input, and also recieve a dust output.
 * @param {String} paymentKeyHex - a hex string of the private key used to
 *    fund the transaction's txfees
 * @param {String} zonefile - the zonefile data to update (this will be hashed
 *    to include in the transaction), the zonefile itself must be published
 *    after the UPDATE propagates.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 *    this function *does not* perform the requisite safety checks -- please see
 *    the safety module for those.
 * @private
 */
function makeUpdate(fullyQualifiedName, ownerKeyHex, paymentKeyHex, zonefile) {
  var network = _config.config.network;
  var valueHash = (0, _utils.hash160)(Buffer.from(zonefile)).toString('hex');

  var ownerKey = (0, _utils2.hexStringToECPair)(ownerKeyHex);
  var paymentKey = (0, _utils2.hexStringToECPair)(paymentKeyHex);

  var paymentAddress = paymentKey.getAddress();
  var ownerAddress = ownerKey.getAddress();

  var txPromise = network.getConsensusHash().then(function (consensusHash) {
    return (0, _skeletons.makeUpdateSkeleton)(fullyQualifiedName, consensusHash, valueHash);
  }).then(function (updateTX) {
    return _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(updateTX, network.layer1);
  });

  return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(function (_ref9) {
    var _ref10 = _slicedToArray(_ref9, 4),
        txB = _ref10[0],
        payerUtxos = _ref10[1],
        ownerUtxos = _ref10[2],
        feeRate = _ref10[3];

    var ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);
    var signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);

    for (var i = 0; i < signingTxB.tx.ins.length; i++) {
      if (i === ownerInput.index) {
        signingTxB.sign(i, ownerKey);
      } else {
        signingTxB.sign(i, paymentKey);
      }
    }
    return signingTxB.build().toHex();
  });
}

/**
 * Generates a register transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to register
 * @param {String} registerAddress - the address to receive the name (this
 *    must have been passed as the 'destinationAddress' in the preorder transaction)
 *    this address will receive a dust UTXO
 * @param {String} paymentKeyHex - a hex string of the private key used to
 *    fund the transaction  (this *must* be the same as the payment
 *    address used to fund the preorder)
 * @param {String} zonefile - the zonefile data to include (this will be hashed
 *    to include in the transaction), the zonefile itself must be published
 *    after the UPDATE propagates.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 *    this function *does not* perform the requisite safety checks -- please see
 *    the safety module for those.
 * @private
 */
function makeRegister(fullyQualifiedName, registerAddress, paymentKeyHex) {
  var zonefile = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var network = _config.config.network;
  var valueHash = undefined;
  if (!!zonefile) {
    valueHash = (0, _utils.hash160)(Buffer.from(zonefile)).toString('hex');
  }

  var registerSkeleton = (0, _skeletons.makeRegisterSkeleton)(fullyQualifiedName, registerAddress, valueHash);

  var txB = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(registerSkeleton, network.layer1);
  var paymentKey = (0, _utils2.hexStringToECPair)(paymentKeyHex);
  var paymentAddress = paymentKey.getAddress();

  return Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()]).then(function (_ref11) {
    var _ref12 = _slicedToArray(_ref11, 2),
        utxos = _ref12[0],
        feeRate = _ref12[1];

    var signingTxB = fundTransaction(txB, paymentAddress, utxos, feeRate, 0);
    for (var i = 0; i < signingTxB.tx.ins.length; i++) {
      signingTxB.sign(i, paymentKey);
    }
    return signingTxB.build().toHex();
  });
}

/**
 * Generates a transfer transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to transfer
 * @param {String} destinationAddress - the address to receive the name.
 *    this address will receive a dust UTXO
 * @param {String} ownerKeyHex - a hex string of the current owner's
 *    private key
 * @param {String} paymentKeyHex - a hex string of the private key used to
 *    fund the transaction
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 *    this function *does not* perform the requisite safety checks -- please see
 *    the safety module for those.
 * @private
 */
function makeTransfer(fullyQualifiedName, destinationAddress, ownerKeyHex, paymentKeyHex) {
  var network = _config.config.network;
  var ownerKey = (0, _utils2.hexStringToECPair)(ownerKeyHex);
  var paymentKey = (0, _utils2.hexStringToECPair)(paymentKeyHex);
  var paymentAddress = paymentKey.getAddress();
  var ownerAddress = ownerKey.getAddress();

  var txPromise = network.getConsensusHash().then(function (consensusHash) {
    return (0, _skeletons.makeTransferSkeleton)(fullyQualifiedName, consensusHash, destinationAddress);
  }).then(function (transferTX) {
    return _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(transferTX, network.layer1);
  });

  return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(function (_ref13) {
    var _ref14 = _slicedToArray(_ref13, 4),
        txB = _ref14[0],
        payerUtxos = _ref14[1],
        ownerUtxos = _ref14[2],
        feeRate = _ref14[3];

    var ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);
    var signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);
    for (var i = 0; i < signingTxB.tx.ins.length; i++) {
      if (i === ownerInput.index) {
        signingTxB.sign(i, ownerKey);
      } else {
        signingTxB.sign(i, paymentKey);
      }
    }
    return signingTxB.build().toHex();
  });
}

/**
 * Generates a transfer transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to transfer
 * @param {String} destinationAddress - the address to receive the name after renewal
 *    this address will receive a dust UTXO
 * @param {String} ownerKeyHex - a hex string of the current owner's
 *    private key
 * @param {String} paymentKeyHex - a hex string of the private key used to
 *    fund the renewal
 * @param {String} zonefile - the zonefile data to include (this will be hashed
 *    to include in the transaction), the zonefile itself must be published
 *    after the RENEWAL propagates.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 *    this function *does not* perform the requisite safety checks -- please see
 *    the safety module for those.
 * @private
 */
function makeRenewal(fullyQualifiedName, destinationAddress, ownerKeyHex, paymentKeyHex) {
  var zonefile = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

  var valueHash = undefined;
  var network = _config.config.network;

  if (!!zonefile) {
    valueHash = (0, _utils.hash160)(Buffer.from(zonefile)).toString('hex');
  }

  var namespace = fullyQualifiedName.split('.').pop();

  var ownerKey = (0, _utils2.hexStringToECPair)(ownerKeyHex);
  var paymentKey = (0, _utils2.hexStringToECPair)(paymentKeyHex);

  var ownerAddress = ownerKey.getAddress();
  var paymentAddress = paymentKey.getAddress();

  var txPromise = Promise.all([network.getNamePrice(fullyQualifiedName), network.getNamespaceBurnAddress(namespace)]).then(function (_ref15) {
    var _ref16 = _slicedToArray(_ref15, 2),
        namePrice = _ref16[0],
        burnAddress = _ref16[1];

    return (0, _skeletons.makeRenewalSkeleton)(fullyQualifiedName, destinationAddress, ownerAddress, burnAddress, namePrice, valueHash);
  }).then(function (tx) {
    return _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(tx, network.layer1);
  });

  return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(function (_ref17) {
    var _ref18 = _slicedToArray(_ref17, 4),
        txB = _ref18[0],
        payerUtxos = _ref18[1],
        ownerUtxos = _ref18[2],
        feeRate = _ref18[3];

    var ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB, false);
    var ownerOutput = txB.tx.outs[2];
    var ownerOutputAddr = _bitcoinjsLib2.default.address.fromOutputScript(ownerOutput.script, network.layer1);
    if (ownerOutputAddr !== ownerAddress) {
      throw new Error('Original owner ' + ownerAddress + ' should have an output at ' + ('index 2 in transaction was ' + ownerOutputAddr));
    }
    ownerOutput.value = ownerInput.value;
    var signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);

    for (var i = 0; i < signingTxB.tx.ins.length; i++) {
      if (i === ownerInput.index) {
        signingTxB.sign(i, ownerKey);
      } else {
        signingTxB.sign(i, paymentKey);
      }
    }
    return signingTxB.build().toHex();
  });
}

/**
 * Generates a bitcoin spend to a specified address. This will fund up to `amount`
 *   of satoshis from the payer's UTXOs. It will generate a change output if and only
 *   if the amount of leftover change is *greater* than the additional fees associated
 *   with the extra output. If the requested amount is not enough to fund the transaction's
 *   associated fees, then this will reject with a InvalidAmountError
 *
 * UTXOs are selected largest to smallest, and UTXOs which cannot fund the fees associated
 *   with their own input will not be included.
 *
 * If you specify an amount > the total balance of the payer address, then this will
 *   generate a maximum spend transaction
 *
 * @param {String} destinationAddress - the address to receive the bitcoin payment
 * @param {String} paymentKeyHex - a hex string of the private key used to
 *    fund the bitcoin spend
 * @param {number} amount - the amount in satoshis for the payment address to
 *    spend in this transaction
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 * @private
 */
function makeBitcoinSpend(destinationAddress, paymentKeyHex, amount) {
  if (amount <= 0) {
    return Promise.reject(new _errors.InvalidParameterError('amount', 'amount must be greater than zero'));
  }

  var network = _config.config.network;
  var paymentKey = (0, _utils2.hexStringToECPair)(paymentKeyHex);
  var paymentAddress = paymentKey.getAddress();

  return Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()]).then(function (_ref19) {
    var _ref20 = _slicedToArray(_ref19, 2),
        utxos = _ref20[0],
        feeRate = _ref20[1];

    var txB = new _bitcoinjsLib2.default.TransactionBuilder(network.layer1);
    var destinationIndex = txB.addOutput(destinationAddress, 0);

    // will add utxos up to _amount_ and return the amount of leftover _change_
    var change = void 0;
    try {
      change = (0, _utils.addUTXOsToFund)(txB, utxos, amount, feeRate, false);
    } catch (err) {
      if (err.name === 'NotEnoughFundsError') {
        // actual amount funded = amount requested - remainder
        amount -= err.leftToFund;
        change = 0;
      } else {
        throw err;
      }
    }

    var feesToPay = feeRate * (0, _utils.estimateTXBytes)(txB, 0, 0);
    var feeForChange = feeRate * (0, _utils.estimateTXBytes)(txB, 0, 1) - feesToPay;

    // it's worthwhile to add a change output
    if (change > feeForChange) {
      feesToPay += feeForChange;
      txB.addOutput(paymentAddress, change);
    }

    // now let's compute how much output is leftover once we pay the fees.
    var outputAmount = amount - feesToPay;
    if (outputAmount < _utils.DUST_MINIMUM) {
      throw new _errors.InvalidAmountError(feesToPay, amount);
    }

    // we need to manually set the output values now
    txB.tx.outs[destinationIndex].value = outputAmount;

    // ready to sign.
    for (var i = 0; i < txB.tx.ins.length; i++) {
      txB.sign(i, paymentKey);
    }
    return txB.build().toHex();
  });
}

var transactions = exports.transactions = {
  makeRenewal: makeRenewal, makeUpdate: makeUpdate, makePreorder: makePreorder, makeRegister: makeRegister, makeTransfer: makeTransfer, makeBitcoinSpend: makeBitcoinSpend,
  estimatePreorder: estimatePreorder, estimateRegister: estimateRegister, estimateTransfer: estimateTransfer, estimateUpdate: estimateUpdate, estimateRenewal: estimateRenewal
};