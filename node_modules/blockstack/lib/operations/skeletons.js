'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makePreorderSkeleton = makePreorderSkeleton;
exports.makeRegisterSkeleton = makeRegisterSkeleton;
exports.makeRenewalSkeleton = makeRenewalSkeleton;
exports.makeTransferSkeleton = makeTransferSkeleton;
exports.makeUpdateSkeleton = makeUpdateSkeleton;

var _bitcoinjsLib = require('bitcoinjs-lib');

var _bitcoinjsLib2 = _interopRequireDefault(_bitcoinjsLib);

var _utils = require('./utils');

var _config = require('../config');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// todo : add name length / character verification


function makePreorderSkeleton(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, burnAmount) {
  var registerAddress = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

  // Returns a preorder tx skeleton.
  //   with 3 outputs : 1. the Blockstack Preorder OP_RETURN data
  //                    2. the Preorder's change address (5500 satoshi minimum)
  //                    3. the BURN
  //
  //    0     2  3                                              23             39
  //    |-----|--|----------------------------------------------|--------------|
  //    magic op  hash160(name.ns_id,script_pubkey,register_addr) consensus hash

  // Returns an unsigned serialized transaction.
  var network = _config.config.network;
  var nameBuff = Buffer.from((0, _utils.decodeB40)(fullyQualifiedName), 'hex'); // base40
  var scriptPublicKey = _bitcoinjsLib2.default.address.toOutputScript(preorderAddress, network.layer1);

  var dataBuffers = [nameBuff, scriptPublicKey];

  if (registerAddress) {
    var registerBuff = Buffer.from(registerAddress, 'ascii');
    dataBuffers.push(registerBuff);
  }

  var dataBuff = Buffer.concat(dataBuffers);

  var hashed = (0, _utils.hash160)(dataBuff);

  var opReturnBuffer = Buffer.alloc(39);
  opReturnBuffer.write('id?', 0, 3, 'ascii');
  hashed.copy(opReturnBuffer, 3);
  opReturnBuffer.write(consensusHash, 23, 16, 'hex');

  var nullOutput = _bitcoinjsLib2.default.script.nullData.output.encode(opReturnBuffer);

  var tx = new _bitcoinjsLib2.default.TransactionBuilder(network.layer1);

  tx.addOutput(nullOutput, 0);
  tx.addOutput(preorderAddress, _utils.DUST_MINIMUM);
  tx.addOutput(burnAddress, burnAmount);

  return tx.buildIncomplete();
}

function makeRegisterSkeleton(fullyQualifiedName, ownerAddress) {
  var valueHash = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  // Returns a register tx skeleton.
  //   with 2 outputs : 1. The register OP_RETURN
  //                    2. The owner address (can be different from REGISTER address on renewals)

  // You MUST make the first input a UTXO from the current OWNER *or* the
  //   funder of the PREORDER

  // in the case of a renewal, this would need to be modified to include a change address
  //  as output (3) before the burn output (4)

  var payload = void 0;
  var network = _config.config.network;

  if (valueHash) {
    if (valueHash.length !== 40) {
      throw new Error('Value hash length incorrect. Expecting 20-bytes, hex-encoded');
    }
    payload = Buffer.alloc(57, 0);
    payload.write(fullyQualifiedName, 0, 37, 'ascii');
    payload.write(valueHash, 37, 20, 'hex');
  } else {
    payload = Buffer.from(fullyQualifiedName, 'ascii');
  }

  var opReturnBuffer = Buffer.concat([Buffer.from('id:', 'ascii'), payload]);
  var nullOutput = _bitcoinjsLib2.default.script.nullData.output.encode(opReturnBuffer);

  var tx = new _bitcoinjsLib2.default.TransactionBuilder(network.layer1);

  tx.addOutput(nullOutput, 0);
  tx.addOutput(ownerAddress, _utils.DUST_MINIMUM);

  return tx.buildIncomplete();
}

function makeRenewalSkeleton(fullyQualifiedName, nextOwnerAddress, lastOwnerAddress, burnAddress, burnAmount) {
  var valueHash = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

  var network = _config.config.network;
  var registerTX = makeRegisterSkeleton(fullyQualifiedName, nextOwnerAddress, valueHash);
  var txB = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(registerTX, network.layer1);
  txB.addOutput(lastOwnerAddress, _utils.DUST_MINIMUM);
  txB.addOutput(burnAddress, burnAmount);
  return txB.buildIncomplete();
}

function makeTransferSkeleton(fullyQualifiedName, consensusHash, newOwner) {
  var keepZonefile = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  // Returns a transfer tx skeleton.
  //   with 2 outputs : 1. the Blockstack Transfer OP_RETURN data
  //                    2. the new owner with a DUST_MINIMUM value (5500 satoshi)
  //
  // You MUST make the first input a UTXO from the current OWNER
  //
  // Returns an unsigned serialized transaction.
  var network = _config.config.network;
  var opRet = Buffer.alloc(36);
  var keepChar = '~';
  if (keepZonefile) {
    keepChar = '>';
  }

  opRet.write('id>', 0, 3, 'ascii');
  opRet.write(keepChar, 3, 1, 'ascii');

  var hashed = (0, _utils.hash128)(Buffer.from(fullyQualifiedName, 'ascii'));
  hashed.copy(opRet, 4);
  opRet.write(consensusHash, 20, 16, 'hex');

  var opRetPayload = _bitcoinjsLib2.default.script.nullData.output.encode(opRet);

  var tx = new _bitcoinjsLib2.default.TransactionBuilder(network.layer1);

  tx.addOutput(opRetPayload, 0);
  tx.addOutput(newOwner, _utils.DUST_MINIMUM);

  return tx.buildIncomplete();
}

function makeUpdateSkeleton(fullyQualifiedName, consensusHash, valueHash) {
  // Returns an update tx skeleton.
  //   with 1 output : 1. the Blockstack update OP_RETURN
  //
  // You MUST make the first input a UTXO from the current OWNER
  //
  // Returns an unsigned serialized transaction.
  var network = _config.config.network;
  var opRet = Buffer.alloc(39);

  var nameBuff = Buffer.from(fullyQualifiedName, 'ascii');
  var consensusBuff = Buffer.from(consensusHash, 'ascii');

  var hashedName = (0, _utils.hash128)(Buffer.concat([nameBuff, consensusBuff]));

  opRet.write('id+', 0, 3, 'ascii');
  hashedName.copy(opRet, 3);
  opRet.write(valueHash, 19, 20, 'hex');

  var opRetPayload = _bitcoinjsLib2.default.script.nullData.output.encode(opRet);

  var tx = new _bitcoinjsLib2.default.TransactionBuilder(network.layer1);

  tx.addOutput(opRetPayload, 0);

  return tx.buildIncomplete();
}